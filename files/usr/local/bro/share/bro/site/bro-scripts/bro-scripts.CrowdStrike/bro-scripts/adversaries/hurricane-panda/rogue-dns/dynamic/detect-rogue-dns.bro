# Detects a Hurricane Panda tactic of using Hurricane Electric to resolve commonly accessed websites
# Alerts when a domain in the Alexa top 500 is resolved via Hurricane Electric and/or when a host connects to an IP in the DNS response
# CrowdStrike 2015
# josh.liburdi@crowdstrike.com

@load base/protocols/dns
@load base/frameworks/notice
@load base/frameworks/input

module CrowdStrike::Hurricane_Panda;

export {
  redef enum Notice::Type += {
    HE_Request,
    HE_Successful_Conn
  };
  
  # File generated by scrape-alexa.py
  const alexa_file = "./alexa_domains.txt" &redef;
}

# Table to store list of domains in file above
global alexa_table: set[string];
# Record for domains in file above
type alexa_idx: record {
  alexa: string;
};

const he_nets: set[subnet] = {
  216.218.130.2,
  216.66.1.2,
  216.66.80.18,
  216.218.132.2,
  216.218.131.2
} &redef;

# Pattern used to identify subdomains
const subdomains =  /^d?ns[0-9]*\./    |
                    /^smtp[0-9]*\./    |
                    /^mail[0-9]*\./    |
                    /^pop[0-9]*\./     |
                    /^imap[0-9]*\./    |
                    /^www[0-9]*\./     |
                    /^ftp[0-9]*\./     |
                    /^img[0-9]*\./     |
                    /^images?[0-9]*\./ |
                    /^search[0-9]*\./  |
                    /^nginx[0-9]*\./ &redef;

# Container to store IP address answers from Hurricane Electric queries
# Each entry expires 5 minutes after the last time it was written
global he_answers: set[addr] &write_expire=5min;

# Pulls data from scrape-alexa.py output (alexa_file)
event bro_init()
{
Input::add_table([$source=alexa_file,
                  $name="alexa_domains",
                  $idx=alexa_idx,
                  $destination=alexa_table,
                  $mode=Input::REREAD]);
}

event DNS::log_dns(rec: DNS::Info)
{
# Do not process the event if no query exists or if the query is not being resolved by Hurricane Electric
if ( ! rec?$query ) return;
if ( rec$id$resp_h !in he_nets ) return;

# If necessary, clean the query so that it can be found in the list of Alexa domains
local query = rec$query;
if ( subdomains in query )
  query = sub(rec$query,subdomains,"");

# Check if the query is in the list of Alexa domains
# If it is, then this activity is suspicious and should be investigated
if ( query in alexa_table )
  {
  # Prepare the sub-message for the notice
  # Include the domain queried in the sub-message
  local sub_msg = fmt("Query: %s",query);

  # If the query was answered, include the answers in the sub-message
  if ( rec?$answers )
    {
    sub_msg += fmt(" %s: ", rec$total_answers > 1 ? "Answers":"Answer");

    for ( ans in rec$answers )
      {
      # If an answers value is an IP address, store it for later processing 
      if ( is_valid_ip(rec$answers[ans]) == T )
        add he_answers[to_addr(rec$answers[ans])];
      sub_msg += fmt("%s, ", rec$answers[ans]);
      }
    
    # Clean the sub-message
    sub_msg = cut_tail(sub_msg,2);
    }

  # Generate the notice
  # Includes the connection flow, host intiating the lookup, domain queried, and query answers (if available)
  NOTICE([$note=HE_Request,
          $msg=fmt("%s made a suspicious DNS lookup to Hurricane Electric", rec$id$orig_h),
          $sub=sub_msg,
          $id=rec$id,
          $uid=rec$uid,
          $identifier=cat(rec$id$orig_h,rec$query)]);
  }
}

event connection_state_remove(c: connection)
{
# Check if a host connected to an IP address seen in an answer from Hurricane Electric
if ( c$id$resp_h in he_answers )
  NOTICE([$note=HE_Successful_Conn,
          $conn=c,
          $msg=fmt("%s connected to a suspicious server resolved by Hurricane Electric", c$id$orig_h),
          $identifier=cat(c$id$orig_h,c$id$resp_h)]);
}
